pipeline {
    agent any

    environment {
        GITHUB_REPO = "${env.GITHUB_REPO ?: 'gmedeirosnet/CI.CD'}"
        GITHUB_BRANCH = "${env.GITHUB_BRANCH ?: 'main'}"
        ARGOCD_NAMESPACE = 'argocd'
        ARGOCD_APP_NAME = 'kyverno-policies'
        KYVERNO_NAMESPACE = 'kyverno'
        POLICIES_PATH = 'k8s/kyverno/policies'
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timestamps()
        timeout(time: 30, unit: 'MINUTES')
    }

    stages {
        stage('Checkout') {
            steps {
                echo "üîÑ Checking out Kyverno policies from GitHub..."
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: "*/${GITHUB_BRANCH}"]],
                    userRemoteConfigs: [[
                        url: "https://github.com/${GITHUB_REPO}.git",
                        credentialsId: 'github-credentials'
                    ]]
                ])
            }
        }

        stage('Validate Policies') {
            steps {
                echo "‚úÖ Validating Kyverno policy files..."
                sh '''
                    # Check if policies directory exists
                    if [ ! -d "${POLICIES_PATH}" ]; then
                        echo "‚ùå Policies directory not found: ${POLICIES_PATH}"
                        exit 1
                    fi

                    # Count policy files
                    POLICY_COUNT=$(find ${POLICIES_PATH} -name "*.yaml" -o -name "*.yml" | wc -l)
                    echo "üìã Found $POLICY_COUNT policy files"

                    # Validate YAML syntax with kubectl dry-run
                    echo "üîç Validating YAML syntax..."
                    for file in $(find ${POLICIES_PATH} -name "*.yaml" -o -name "*.yml"); do
                        echo "Checking: $file"
                        kubectl apply --dry-run=client -f $file || exit 1
                    done

                    echo "‚úÖ All policy files are valid"
                '''
            }
        }

        stage('Check Kyverno Installation') {
            steps {
                echo "üîç Checking Kyverno installation..."
                sh '''
                    # Check if Kyverno namespace exists
                    if ! kubectl get namespace ${KYVERNO_NAMESPACE} > /dev/null 2>&1; then
                        echo "‚ùå Kyverno namespace not found"
                        echo "Please install Kyverno first using: k8s/kyverno/install/setup-kyverno.sh"
                        exit 1
                    fi

                    # Check if Kyverno pods are running
                    RUNNING_PODS=$(kubectl get pods -n ${KYVERNO_NAMESPACE} --field-selector=status.phase=Running --no-headers | wc -l)
                    if [ "$RUNNING_PODS" -lt 3 ]; then
                        echo "‚ö†Ô∏è  Warning: Only $RUNNING_PODS Kyverno pods are running"
                    else
                        echo "‚úÖ Kyverno is running with $RUNNING_PODS pods"
                    fi

                    # Show Kyverno pods status
                    echo ""
                    echo "Kyverno Pods:"
                    kubectl get pods -n ${KYVERNO_NAMESPACE}
                '''
            }
        }

        stage('Check/Create ArgoCD Application') {
            steps {
                echo "üîç Checking ArgoCD Application..."
                sh '''
                    # Check if ArgoCD Application exists
                    if kubectl get application ${ARGOCD_APP_NAME} -n ${ARGOCD_NAMESPACE} > /dev/null 2>&1; then
                        echo "‚úÖ ArgoCD Application '${ARGOCD_APP_NAME}' exists"
                        echo ""
                        echo "Current Application Status:"
                        kubectl get application ${ARGOCD_APP_NAME} -n ${ARGOCD_NAMESPACE} \
                            -o jsonpath='{.status.sync.status}' && echo ""
                    else
                        echo "üìù Creating ArgoCD Application for Kyverno policies..."

                        if [ -f "argocd-apps/kyverno-policies.yaml" ]; then
                            kubectl apply -f argocd-apps/kyverno-policies.yaml
                            echo "‚úÖ ArgoCD Application created"
                        else
                            echo "‚ùå ArgoCD Application manifest not found at argocd-apps/kyverno-policies.yaml"
                            exit 1
                        fi
                    fi
                '''
            }
        }

        stage('Sync with ArgoCD') {
            steps {
                echo "üîÑ Syncing policies via ArgoCD..."
                sh '''
                    # Trigger ArgoCD refresh and sync via kubectl annotation
                    echo "Triggering ArgoCD hard refresh..."
                    kubectl patch application ${ARGOCD_APP_NAME} -n ${ARGOCD_NAMESPACE} \
                        --type merge \
                        -p '{"metadata":{"annotations":{"argocd.argoproj.io/refresh":"hard"}}}'

                    echo "Waiting for ArgoCD to sync..."
                    sleep 15

                    # Check sync status
                    SYNC_STATUS=$(kubectl get application ${ARGOCD_APP_NAME} -n ${ARGOCD_NAMESPACE} \
                        -o jsonpath='{.status.sync.status}')
                    HEALTH_STATUS=$(kubectl get application ${ARGOCD_APP_NAME} -n ${ARGOCD_NAMESPACE} \
                        -o jsonpath='{.status.health.status}')

                    echo ""
                    echo "ArgoCD Sync Status: $SYNC_STATUS"
                    echo "ArgoCD Health Status: $HEALTH_STATUS"

                    if [ "$SYNC_STATUS" != "Synced" ]; then
                        echo "‚ö†Ô∏è  Warning: Application not fully synced yet"
                    fi
                '''
            }
        }

        stage('Verify Deployment') {
            steps {
                echo "‚úÖ Verifying policy deployment..."
                sh '''
                    echo "üìä Current ClusterPolicies in cluster:"
                    kubectl get clusterpolicies

                    echo ""
                    echo "üìã Policy Details:"
                    kubectl get clusterpolicies -o custom-columns=\
NAME:.metadata.name,\
BACKGROUND:.spec.background,\
ACTION:.spec.validationFailureAction,\
READY:.status.ready

                    echo ""
                    POLICY_COUNT=$(kubectl get clusterpolicies --no-headers | wc -l)
                    echo "Total Policies Deployed: $POLICY_COUNT"
                '''
            }
        }

        stage('Policy Reports Summary') {
            steps {
                echo "üìà Generating policy reports summary..."
                sh '''
                    echo "Policy Report Statistics:"
                    echo "------------------------"

                    NAMESPACE_REPORTS=$(kubectl get policyreport -A --no-headers 2>/dev/null | wc -l)
                    CLUSTER_REPORTS=$(kubectl get clusterpolicyreport --no-headers 2>/dev/null | wc -l)

                    echo "Namespace Policy Reports: $NAMESPACE_REPORTS"
                    echo "Cluster Policy Reports: $CLUSTER_REPORTS"
                    echo "Total Reports: $((NAMESPACE_REPORTS + CLUSTER_REPORTS))"

                    echo ""
                    echo "Recent ClusterPolicyReports:"
                    kubectl get clusterpolicyreport -o custom-columns=\
NAME:.metadata.name,\
PASS:.summary.pass,\
FAIL:.summary.fail,\
WARN:.summary.warn,\
SKIP:.summary.skip 2>/dev/null || echo "No cluster reports yet"
                '''
            }
        }

        stage('Test Policy Enforcement') {
            steps {
                echo "üß™ Testing policy enforcement..."
                sh '''
                    echo "Testing prevent-namespace-deletion policy..."

                    # Test dry-run delete of protected namespace
                    if kubectl delete namespace argocd --dry-run=client 2>&1 | grep -i "not allowed\\|blocked\\|denied"; then
                        echo "‚úÖ Namespace deletion policy is working correctly"
                    else
                        echo "‚ö†Ô∏è  Warning: Namespace deletion test did not return expected block message"
                        echo "This may be normal if the policy is in Audit mode"
                    fi

                    echo ""
                    echo "üéØ Policy deployment and enforcement verification complete"
                '''
            }
        }

        stage('Policy Reporter Status') {
            steps {
                echo "üìä Checking Policy Reporter integration..."
                sh '''
                    # Check if Policy Reporter is running
                    if docker ps 2>/dev/null | grep -q policy-reporter; then
                        echo "‚úÖ Policy Reporter containers are running"

                        # Test API endpoint
                        if curl -sf http://localhost:31001/healthz > /dev/null 2>&1; then
                            echo "‚úÖ Policy Reporter API is accessible at http://localhost:31001"
                            echo "‚úÖ Policy Reporter UI is accessible at http://localhost:31002"
                        else
                            echo "‚ö†Ô∏è  Policy Reporter API is not responding"
                        fi
                    else
                        echo "‚ÑπÔ∏è  Policy Reporter is not running (optional component)"
                        echo "   To install: cd k8s/kyverno/policy-reporter && ./install-policy-reporter.sh"
                    fi
                '''
            }
        }
    }

    post {
        success {
            echo """
                ‚úÖ Kyverno Policies Deployment Successful!

                üìä Summary:
                - Policies validated and synced via ArgoCD
                - All policies deployed to cluster
                - Policy enforcement is active

                üîó Access Points:
                - ArgoCD UI: https://localhost:8090
                - Policy Reporter UI: http://localhost:31002
                - Policy Reporter API: http://localhost:31001

                üìã Next Steps:
                - Monitor policy violations in Policy Reporter
                - Review policy reports: kubectl get policyreport -A
                - Check ArgoCD for sync status
            """
        }
        failure {
            echo """
                ‚ùå Kyverno Policies Deployment Failed

                Please check:
                1. Kyverno is installed: kubectl get pods -n kyverno
                2. ArgoCD is running: kubectl get pods -n argocd
                3. Policy files are valid: kubectl apply --dry-run=client -f k8s/kyverno/policies/
                4. GitHub credentials are configured in Jenkins

                üìù Logs above contain detailed error information
            """
        }
        always {
            echo "üèÅ Pipeline execution completed"
            cleanWs()
        }
    }
}
